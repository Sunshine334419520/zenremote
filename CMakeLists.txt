cmake_minimum_required(VERSION 3.23)
project(zenremote)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(nlohmann_json)
find_package(Qt6 REQUIRED COMPONENTS Core Widgets Gui)
find_package(ffmpeg REQUIRED)
find_package(spdlog REQUIRED)
find_package(SDL2 REQUIRED)
find_package(fmt REQUIRED)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

if (WIN32)
    add_definitions(-DOS_WIN)
    add_definitions(-DNOMINMAX)
elseif(APPLE)
    add_definitions(-DOS_MAC)
elseif(UNIX)
    add_definitions(-DOS_LINUX)
endif()

# spdlog 编译期日志级别配置
# 编译期：决定哪些日志代码会被编译进程序
# 运行期：LogManager::Initialize() 决定哪些日志实际输出
# 
# Debug 模式：编译所有级别（包括 TRACE/DEBUG），方便调试
# Release 模式：只编译 INFO 及以上，减小程序体积和性能开销
#
# 注意：Visual Studio 是多配置生成器，CMAKE_BUILD_TYPE 在配置时为空
# 需要使用生成器表达式在编译时根据配置选择不同的宏定义
if (CMAKE_CONFIGURATION_TYPES)
    # 多配置生成器（Visual Studio, Xcode）
    # 使用生成器表达式在编译时动态选择
    add_compile_definitions(
        $<$<CONFIG:Debug>:SPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_TRACE>
        $<$<CONFIG:Release>:SPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO>
        $<$<CONFIG:RelWithDebInfo>:SPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_DEBUG>
        $<$<CONFIG:MinSizeRel>:SPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO>
    )
    message(STATUS "spdlog compile-time level: Multi-config (Debug=TRACE, Release=INFO)")
else()
    # 单配置生成器（Ninja, Unix Makefiles）
    if (CMAKE_BUILD_TYPE STREQUAL "Debug")
        add_definitions(-DSPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_TRACE)
        message(STATUS "spdlog compile-time level: TRACE (Debug build)")
    else()
        add_definitions(-DSPDLOG_ACTIVE_LEVEL=SPDLOG_LEVEL_INFO)
        message(STATUS "spdlog compile-time level: INFO (Release build)")
    endif()
endif()

# ==================== ConfigManager 编译配置 ====================
# 
# ConfigManager 支持两种模式：
# 1. Loki 派遣模式（推荐）：使用 Loki 任务派遣，无锁访问
# 2. 直接调用模式：直接调用 GlobalConfig，使用读写锁
#
# 配置宏：
# - ZENREMOTE_CONFIG_USE_LOKI_DISPATCH: 是否使用 Loki 派遣（1=使用，0=不使用）
# - ZENREMOTE_CONFIG_USE_LOCK: 是否使用读写锁（1=使用，0=不使用）
#
# 推荐组合：
# - LOKI_DISPATCH=1 + USE_LOCK=0：使用 Loki，IO 线程独占访问，无锁（性能最优）
# - LOKI_DISPATCH=0 + USE_LOCK=1：不使用 Loki，多线程并发，有锁（兼容模式）

# 检查是否添加了 Loki
add_subdirectory(third_party/loki)

# 配置 ConfigManager 模式
if(TARGET loki)
    # 有 Loki：使用派遣模式（推荐）
    add_definitions(-DZENREMOTE_CONFIG_USE_LOKI_DISPATCH=1)
    add_definitions(-DZENREMOTE_CONFIG_USE_LOCK=0)
    message(STATUS "ConfigManager: 使用 Loki 派遣模式（无锁，性能最优）")
    message(STATUS "  - ZENREMOTE_CONFIG_USE_LOKI_DISPATCH=1")
    message(STATUS "  - ZENREMOTE_CONFIG_USE_LOCK=0")
else()
    # 无 Loki：使用直接调用模式（兼容）
    add_definitions(-DZENREMOTE_CONFIG_USE_LOKI_DISPATCH=0)
    add_definitions(-DZENREMOTE_CONFIG_USE_LOCK=1)
    message(STATUS "ConfigManager: 使用直接调用模式（有锁）")
    message(STATUS "  - ZENREMOTE_CONFIG_USE_LOKI_DISPATCH=0")
    message(STATUS "  - ZENREMOTE_CONFIG_USE_LOCK=1")
endif()

# 可选：手动覆盖配置（用于调试或测试）
# 取消下面的注释来强制使用特定模式：
#
# # 强制使用 Loki 派遣 + 无锁模式
# add_definitions(-DZENREMOTE_CONFIG_USE_LOKI_DISPATCH=1)
# add_definitions(-DZENREMOTE_CONFIG_USE_LOCK=0)
#
# # 强制使用直接调用 + 有锁模式（便于调试）
# add_definitions(-DZENREMOTE_CONFIG_USE_LOKI_DISPATCH=0)
# add_definitions(-DZENREMOTE_CONFIG_USE_LOCK=1)

# src files
file(GLOB SRC_FILES "src/main.cpp")
# file(GLOB MAIN_FILES 
#    "src/player/zen_player.cpp"
#    "src/player/zen_player.h"
#    "src/player/playback_controller.h"
#    "src/player/playback_controller.cpp")
file(GLOB COMMON_FILES
    "src/common/*.cpp"
    "src/common/*.h"
)
file(GLOB PLAYER_CONFIG_FILES
    "src/config/*.cpp"
    "src/config/*.h"
)

# Application layer (session + ui)
file(GLOB_RECURSE APP_FILES "src/app/*.cpp" "src/app/*.h" "src/app/*.ui")

# Transport layer (transmission abstractions)
file(GLOB_RECURSE TRANSPORT_FILES "src/transport/*.cpp" "src/transport/*.h")

# Network layer (network implementation)
file(GLOB_RECURSE NETWORK_FILES "src/network/*.cpp" "src/network/*.h")

# Other layers
file(GLOB_RECURSE CONTROL_FILES "src/control/*.cpp" "src/control/*.h")
file(GLOB_RECURSE CORE_FILES "src/core/*.cpp" "src/core/*.h")
file(GLOB_RECURSE MEDIA_FILES "src/media/*.cpp" "src/media/*.h")


list(APPEND SRC_FILES ${MAIN_FILES})
list(APPEND SRC_FILES ${COMMON_FILES})
list(APPEND SRC_FILES ${CONFIG_FILES})
list(APPEND SRC_FILES ${APP_FILES})
list(APPEND SRC_FILES ${TRANSPORT_FILES})
list(APPEND SRC_FILES ${NETWORK_FILES})
list(APPEND SRC_FILES ${CONTROL_FILES})
list(APPEND SRC_FILES ${CORE_FILES})
list(APPEND SRC_FILES ${MEDIA_FILES})

# resource files
# set(QRC_FILES resources/zenremote.qrc)

# Windows 控制台配置
# Debug 模式：显示控制台窗口（方便查看日志）
# Release 模式：不显示控制台（纯 GUI 应用）
# 
# 注意：对于 Visual Studio 多配置生成器，需要在构建时指定配置
# Debug 构建：cmake --build build --config Debug
# Release 构建：cmake --build build --config Release
if (WIN32)
    # 默认不添加 WIN32 标志，显示控制台（开发友好）
    # 如果需要 Release 无控制台，手动构建时添加 WIN32 属性
    add_executable(${PROJECT_NAME} ${SRC_FILES} ${QRC_FILES})
    
    # 设置 Release 配置为 WIN32 应用（无控制台）
    set_target_properties(${PROJECT_NAME} PROPERTIES
        WIN32_EXECUTABLE $<IF:$<CONFIG:Debug>,FALSE,TRUE>
    )
else()
    add_executable(${PROJECT_NAME} ${SRC_FILES} ${QRC_FILES})
endif()

target_link_libraries(${PROJECT_NAME} PRIVATE 
    nlohmann_json::nlohmann_json
    Qt6::Core
    Qt6::Widgets
    Qt6::Gui
    ffmpeg::avutil
    ffmpeg::avcodec
    ffmpeg::avformat
    ffmpeg::avfilter
    ffmpeg::swscale
    spdlog::spdlog
    SDL2::SDL2
    SDL2::SDL2main
    loki
    fmt::fmt
)

# Windows 平台添加 D3D11 和 DXGI 库（硬件加速渲染）
if (WIN32)
    target_link_libraries(${PROJECT_NAME} PRIVATE 
        d3d11.lib
        dxgi.lib
        d3dcompiler.lib
        ws2_32.lib
    )
endif()

target_include_directories(${PROJECT_NAME} PRIVATE 
    ${CMAKE_CURRENT_SOURCE_DIR}/src
    ${CMAKE_CURRENT_SOURCE_DIR}/third_party
)

if (MSVC)
    find_program(DEPLOYQT_EXECUTABLE NAMES windeployqt)
    if (DEPLOYQT_EXECUTABLE)
        # 只在 Release 模式下运行 windeployqt
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND $<$<CONFIG:Release>:${DEPLOYQT_EXECUTABLE}> $<$<CONFIG:Release>:$<TARGET_FILE:${PROJECT_NAME}>>
            COMMENT "Deploying Qt libraries (Release mode only)")
    else()
        message(WARNING "windeployqt not found, Qt libraries will not be deployed automatically.")
    endif()
endif()

if (APPLE)
    # macOS specific deployment
    find_program(DEPLOYQT_EXECUTABLE NAMES macdeployqt)
        if (DEPLOYQT_EXECUTABLE)
            add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${DEPLOYQT_EXECUTABLE} $<TARGET_FILE:${PROJECT_NAME}>
            COMMENT "Deploying Qt libraries with macdeployqt")
        else()
            message(WARNING "macdeployqt not found, Qt libraries will not be deployed automatically.")
        endif()
endif()

# 单元测试（可选，通过 BUILD_TESTING 控制）
option(BUILD_TESTING "Build the testing tree" ON)
if (BUILD_TESTING)
    enable_testing()
    add_subdirectory(tests)
    message(STATUS "Unit tests enabled. Run with: ctest or ./build/tests/zenplay_tests")
endif()